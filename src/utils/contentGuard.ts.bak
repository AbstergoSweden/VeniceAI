/**
 * contentGuard.ts — Content safety guard for NSFW prompts (adult-only enforcement)
 * License: MIT
 * Purpose: HARD-BLOCK any prompt that references minors (explicitly or implicitly)
 * 
 * This module evaluates input text and blocks content that implies minors.
 * It does NOT generate sexual content, only validates prompts for safety.
 */

// ============================================================================
// Types & Interfaces
// ============================================================================

export interface Decision {
    allow: boolean;
    action: 'ALLOW' | 'BLOCK' | 'REWRITE';
    reason: string;
    normalizedPrompt: string;
    rewrittenPrompt: string | null;
    signals: Signals;
}

export interface Signals {
    hardTerms: string[];
    ambiguousYouth: string[];
    adultAssertions: string[];
    ages: number[];
    schoolContext: string[];
    injections: string[];          // Detected injection attempts
    crossSentence: string[];       // Terms found across sentence boundaries
    clusterScore: number;          // Risk score from term clustering
    severity: string;              // Risk severity level
    contextScore: number;          // Overall context risk score
    fuzzyMatches: FuzzyMatch[];    // Fuzzy matching results
    normalized: string;
}

export interface FuzzyMatch {
    window: string;                // Text window that matched
    matchType: 'soundex' | 'simhash' | 'jaccard';
    term: string;                  // Term it matched against
    confidence: number;            // Match confidence/distance
}

// ============================================================================
// Constants & Patterns
// ============================================================================

// Zero-width characters
const ZERO_WIDTH_RE = /[\u200B-\u200D\uFEFF]/g;

// Combining marks (accents)
const COMBINING_MARKS_RE = /[\u0300-\u036f]/g;

// Whitespace normalization
const WHITESPACE_RE = /\s+/g;

// Leetspeak character mapping
const LEET_MAP: Record<string, string> = {
    '0': 'o',
    '1': 'i',
    '3': 'e',
    '4': 'a',
    '5': 's',
    '7': 't',
    '@': 'a',
    '$': 's',
};

// Homoglyph character mapping (lookalike characters)
const HOMOGLYPH_MAP: Record<string, string> = {
    '¡': 'i', 'Ｉ': 'i', 'і': 'i', 'Ⅰ': 'i',
    'ⓞ': 'o', '○': 'o', '◯': 'o', 'Ｏ': 'o', 'о': 'o',
    'ⓐ': 'a', 'а': 'a', 'Ａ': 'a',
    'ⓔ': 'e', 'ｅ': 'e', 'е': 'e',
    'ⓢ': 's', 'Ｓ': 's',
    'ⓣ': 't', 'Ｔ': 't',
    'ⓤ': 'u', 'Ｕ': 'u',
    'ⓡ': 'r', 'Ｒ': 'r',
    'ⓛ': 'l', 'Ｌ': 'l',
    'ⓑ': 'b', 'Ｂ': 'b',
    'ⓙ': 'j', 'Ｊ': 'j',
};

// Hard signals implying minors — absolutely block
const HARD_TERMS = [
    // slur/genre terms
    'loli', 'lolicon', 'shotacon', 'shota',
    // explicit words
    'child', 'children', 'kid', 'kids', 'minor', 'underage', 'under-aged',
    'preteen', 'preteens', 'tween',
    // roles
    'schoolgirl', 'school boy', 'schoolboy', 'school girl',
    'middle school', 'elementary', 'kindergarten', 'grade school',
    'babysitter', 'babysit', 'babysitting',
    // faces
    'baby face', 'babyface', 'childlike', 'child-like',
];

// Soft-but-dangerous descriptors — blocked regardless (strict policy)
const AMBIGUOUS_YOUTH = [
    'teen', 'teens', 'teenage', 'jailbait', 'young-looking', 'looks young',
    'youthful', 'nubile', 'barely legal', 'college freshman',
    'looks like a kid', 'girl next door', 'boyish', 'girlish', 'tiny girl',
    'innocent-looking', 'school uniform',
];

// Adult affirmations (for signal tracking, not whitelisting)
const ADULT_ASSERTIONS = [
    'adult', '18+', 'eighteen plus', 'over 18', 'over 21', '21+', 'twenty one',
    'grown woman', 'grown man', 'mature', 'of age',
];

// Age patterns: block < 18, allow >= 18
const AGE_PATTERNS = [
    /\b(\d{1,2})\s*(?:yo|y\/o|yrs? old|years? old)\b/gi,
    /\b(?:age)\s*[:=]\s*(\d{1,2})\b/gi,
    /\b(\d{1,2})\s*(?:-?\s*year\s*old)\b/gi,
];

// Grades and school years implying K-12 contexts
const SCHOOL_PATTERNS = [
    /\b(?:k|kinder(?:garten)?)\b/gi,
    /\b(?:1st|2nd|3rd|[4-9]th)\s*grade\b/gi,
    /\b(?:middle\s*school|junior\s*high|high\s*school)\b/gi,
    /\b(?:hs|jr\.?\s*high)\b/gi,
    /\b(?:elementary\s*schooler?)\b/gi,
];

// Adult term normalization (typo corrections)
const ADULT_NORMALIZATION: Record<string, string> = {
    'boobiies': 'boobies',
    'boobiiies': 'boobies',
    'boobiiees': 'boobies',
    'boobiess': 'boobies',
    'b00bies': 'boobies',
    't1tties': 'titties',
};

// Prompt injection attempts — block these to prevent jailbreaking
const INJECTION_TERMS = [
    'ignore previous', 'bypass filter', 'disable safety', 'jailbreak',
    'pretend you are', 'roleplay as', 'act as if', 'for educational purposes',
    'hypothetically', 'in a fictional scenario', 'as a creative writing exercise',
    'ignore instructions', 'override', 'system prompt', 'reset context',
];

const INJECTION_PATTERNS = [
    /\b(DAN|STAN|AIM|Developer Mode)\b/gi,
    /\bignore\s+all\s+(previous|prior)\s+(instructions?|prompts?)\b/gi,
    /\bdisregard\s+(previous|prior|all)\b/gi,
];

// Severity levels for risk categorization
const SEVERITY_LEVELS: Record<string, string[]> = {
    CRITICAL: ['loli', 'lolicon', 'shota', 'shotacon', 'child porn', 'pedo', 'pedophile', 'toddler', 'infant', 'csam'],
    HIGH: ['kid', 'kids', 'minor', 'underage', 'preteen', 'child', 'children', 'tween'],
    MEDIUM: ['teen', 'teens', 'teenage', 'teenager', 'jailbait', 'barely legal'],
    LOW: ['youthful', 'nubile', 'young-looking'],
};

// Risky term clusters — combinations that are high-risk when appearing together
const RISKY_CLUSTERS: Set<string>[][] = [
    [new Set(['small', 'petite', 'tiny', 'little']), new Set(['girl', 'boy', 'kid', 'child'])],
    [new Set(['innocent', 'naive', 'pure', 'sweet']), new Set(['girl', 'boy', 'teen', 'young'])],
    [new Set(['school', 'uniform', 'student']), new Set(['girl', 'boy', 'sexy', 'hot'])],
];

// Configuration constants
const CONTEXT_SCORE_THRESHOLD = 10;  // Score above this triggers block
const CLUSTER_MATCH_THRESHOLD = 2;   // Minimum terms from each cluster set
const HAMMING_DISTANCE_THRESHOLD = 5; // For simhash fuzzy matching
const SOUNDEX_MIN_LENGTH = 4;        // Minimum word length for soundex matching

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Fold homoglyph characters to their ASCII equivalents
 */
function foldHomoglyphs(s: string): string {
    return Array.from(s)
        .map(ch => HOMOGLYPH_MAP[ch] || ch)
        .join('');
}

/**
 * Convert leetspeak characters to normal letters
 */
function convertLeetspeak(s: string): string {
    return Array.from(s)
        .map(ch => LEET_MAP[ch] || ch)
        .join('');
}

/**
 * Normalize text for term matching: removes punctuation to create word boundaries
 */
function normalizeForMatching(s: string): string {
    // Remove all non-letter, non-number, non-space characters to create clean word boundaries
    return ` ${s.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, ' ')} `;
}

/**
 * Normalize text: remove zero-width chars, normalize Unicode, fold homoglyphs,
 * convert leetspeak, remove combining marks, normalize whitespace
 */
export function normalizeText(s: string): string {
    let normalized = s.trim();

    // Replace Unicode line/paragraph separators
    normalized = normalized.replace(/\u2028/g, ' ').replace(/\u2029/g, ' ');

    // Remove zero-width characters
    normalized = normalized.replace(ZERO_WIDTH_RE, '');

    // Unicode normalization (NFKC)
    normalized = normalized.normalize('NFKC');

    // Fold homoglyphs
    normalized = foldHomoglyphs(normalized);

    // Convert leetspeak (before removing combining marks to handle accented leetspeak)
    normalized = convertLeetspeak(normalized);

    // Remove combining marks (accents)
    normalized = normalized.replace(COMBINING_MARKS_RE, '');

    // Normalize whitespace
    normalized = normalized.replace(WHITESPACE_RE, ' ');

    return normalized;
}

/**
 * Normalize adult content typos
 */
function normalizeAdultTypos(s: string): string {
    // Remove punctuation before tokenizing to handle cases like "boobiies!" or "big-boobiies"
    const tokens = s
        .toLowerCase()
        .replace(/[^\p{L}\p{N}\s]/gu, ' ')
        .split(/\s+/)
        .filter(t => t.length > 0);

    const normalized = tokens.map(token => {
        return ADULT_NORMALIZATION[token] || token;
    });
    return normalized.join(' ');
}

/**
 * Check if normalized text contains any of the given terms
 * Uses punctuation-aware boundary matching to prevent bypasses like "teen-girl" or "loli,"
 */
function hasTerms(text: string, terms: string[]): string[] {
    const hits: string[] = [];
    const normalizedText = normalizeForMatching(text);

    for (const term of terms) {
        const normalizedTerm = normalizeForMatching(term).trim();
        if (normalizedText.includes(` ${normalizedTerm} `)) {
            hits.push(term);
        }
    }

    return hits;
}

/**
 * Extract ages from text using age patterns
 * Filters to human-reasonable ages (0-120) to prevent garbage matches
 */
function findAges(text: string): number[] {
    const ages: number[] = [];

    for (const pattern of AGE_PATTERNS) {
        const matches = text.matchAll(pattern);
        for (const match of matches) {
            const groups = match.slice(1).filter(g => g && /^\d{1,2}$/.test(g));
            for (const group of groups) {
                const age = parseInt(group, 10);
                // Only accept human-reasonable ages to prevent garbage/abuse
                if (!isNaN(age) && age >= 0 && age <= 120) {
                    ages.push(age);
                }
            }
        }
    }

    return ages;
}

/**
 * Detect K-12 school contexts
 */
function findSchoolContext(text: string): string[] {
    const hits: string[] = [];

    for (const pattern of SCHOOL_PATTERNS) {
        const matches = text.matchAll(pattern);
        for (const match of matches) {
            hits.push(match[0]);
        }
    }

    return hits;
}

// ============================================================================
// Fuzzy Matching Algorithms
// ============================================================================

/**
 * Soundex algorithm for phonetic matching
 * Converts words to phonetic codes to catch misspellings
 */
function soundex(s: string): string {
    // Remove non-alphabetic characters and uppercase
    const clean = s.replace(/[^a-zA-Z]/g, '').toUpperCase();
    if (!clean) return 'Z000';

    const first = clean[0];
    const mapping: Record<string, string> = {
        'B': '1', 'F': '1', 'P': '1', 'V': '1',
        'C': '2', 'G': '2', 'J': '2', 'K': '2', 'Q': '2', 'S': '2', 'X': '2', 'Z': '2',
        'D': '3', 'T': '3',
        'L': '4',
        'M': '5', 'N': '5',
        'R': '6',
    };

    let code = first;
    let prevCode = '';

    for (let i = 1; i < clean.length; i++) {
        const ch = clean[i];
        const digit = mapping[ch] || '';

        // Only add if different from previous and not empty
        if (digit && digit !== prevCode) {
            code += digit;
            prevCode = digit;
        } else if (!digit) {
            prevCode = '';
        }
    }

    // Pad or truncate to 4 characters
    return (code + '0000').substring(0, 4);
}

/**
 * Calculate character n-grams for a string
 */
function charNgrams(s: string, n: number): Set<string> {
    const padded = ` ${s} `;
    const grams = new Set<string>();

    if (padded.length < n) {
        grams.add(padded);
        return grams;
    }

    for (let i = 0; i <= padded.length - n; i++) {
        grams.add(padded.substring(i, i + n));
    }

    return grams;
}

/**
 * Simhash algorithm for near-duplicate detection
 * Uses character n-grams and returns a hash value
 */
function simhash(text: string, n: number = 3, bits: number = 64): bigint {
    const grams = Array.from(charNgrams(text.toLowerCase(), n));

    if (grams.length === 0) {
        return BigInt(0);
    }

    // Count n-gram frequencies
    const weights: Record<string, number> = {};
    for (const gram of grams) {
        weights[gram] = (weights[gram] || 0) + 1;
    }

    // Initialize bit vectors
    const v: number[] = new Array(bits).fill(0);

    // Hash each n-gram and update bit vectors
    for (const [gram, weight] of Object.entries(weights)) {
        const hash = simpleHash(gram, bits);
        for (let i = 0; i < bits; i++) {
            const bit = (hash >> BigInt(i)) & BigInt(1);
            v[i] += bit === BigInt(1) ? weight : -weight;
        }
    }

    // Generate final hash from bit vectors
    let result = BigInt(0);
    for (let i = 0; i < bits; i++) {
        if (v[i] > 0) {
            result |= BigInt(1) << BigInt(i);
        }
    }

    return result;
}

/**
 * Simple hash function for simhash
 */
function simpleHash(s: string, bits: number): bigint {
    let hash = BigInt(0);
    for (let i = 0; i < s.length; i++) {
        hash = (hash * BigInt(31) + BigInt(s.charCodeAt(i))) & ((BigInt(1) << BigInt(bits)) - BigInt(1));
    }
    return hash;
}

/**
 * Calculate Hamming distance between two bigints
 */
function hammingDistance(a: bigint, b: bigint): number {
    let xor = a ^ b;
    let distance = 0;

    while (xor > BigInt(0)) {
        distance += Number(xor & BigInt(1));
        xor >>= BigInt(1);
    }

    return distance;
}

/**
 * Jaccard similarity coefficient
 */
function jaccardSimilarity(set1: Set<string>, set2: Set<string>): number {
    if (set1.size === 0 || set2.size === 0) {
        return 0;
    }

    const intersection = new Set([...set1].filter(x => set2.has(x)));
    const union = new Set([...set1, ...set2]);

    return intersection.size / union.size;
}

/**
 * Perform fuzzy matching on text windows against known risky terms
 */
function fuzzyMatchTerms(text: string): FuzzyMatch[] {
    const matches: FuzzyMatch[] = [];
    const tokens = text.toLowerCase().split(/\s+/).filter(t => t.length >= SOUNDEX_MIN_LENGTH);

    // Create sliding windows (1-3 tokens)
    const windows: string[] = [];
    for (let size = 1; size <= 3 && size <= tokens.length; size++) {
        for (let i = 0; i <= tokens.length - size; i++) {
            const window = tokens.slice(i, i + size).join(' ');
            if (window.length <= 24) { // Limit window length
                windows.push(window);
            }
        }
    }

    // Check each window against risky terms
    const riskyTerms = [...HARD_TERMS, ...AMBIGUOUS_YOUTH];

    for (const window of windows) {
        const windowSoundex = soundex(window);
        const windowSimhash = simhash(window);
        const windowNgrams = charNgrams(window, 3);

        for (const term of riskyTerms) {
            // Skip if already exact match (will be caught by hasTerms)
            if (window === term) continue;

            // Soundex matching
            if (windowSoundex === soundex(term) && window.length >= SOUNDEX_MIN_LENGTH) {
                matches.push({
                    window,
                    matchType: 'soundex',
                    term,
                    confidence: 1.0,
                });
                break; // Found match for this window
            }

            // Simhash matching
            const termSimhash = simhash(term);
            const distance = hammingDistance(windowSimhash, termSimhash);
            if (distance <= HAMMING_DISTANCE_THRESHOLD) {
                matches.push({
                    window,
                    matchType: 'simhash',
                    term,
                    confidence: 1 - (distance / 64),
                });
                break;
            }

            // Jaccard similarity matching
            const termNgrams = charNgrams(term, 3);
            const similarity = jaccardSimilarity(windowNgrams, termNgrams);
            if (similarity >= 0.75) {
                matches.push({
                    window,
                    matchType: 'jaccard',
                    term,
                    confidence: similarity,
                });
                break;
            }
        }
    }

    return matches;
}

// ============================================================================
// Context Analysis Functions
// ============================================================================


/**
 * Determine severity level based on detected terms
 */
function determineSeverity(hardTerms: string[], ambiguousYouth: string[]): string {
    const allTerms = [...hardTerms, ...ambiguousYouth];

    for (const [level, terms] of Object.entries(SEVERITY_LEVELS)) {
        if (allTerms.some(term => terms.includes(term))) {
            return level;
        }
    }

    return 'UNKNOWN';
}

/**
 * Detect risky term clusters (combinations of terms that are high-risk together)
 */
function detectClusters(text: string): number {
    const normalizedText = normalizeForMatching(text);
    let clusterScore = 0;

    for (const clusterPair of RISKY_CLUSTERS) {
        let matchCounts = clusterPair.map(() => 0);

        clusterPair.forEach((termSet, idx) => {
            for (const term of termSet) {
                if (normalizedText.includes(` ${term} `)) {
                    matchCounts[idx]++;
                }
            }
        });

        // If we have matches from each set in the cluster pair
        if (matchCounts.every(count => count >= CLUSTER_MATCH_THRESHOLD)) {
            clusterScore += 5;
        } else if (matchCounts.every(count => count >= 1)) {
            clusterScore += 2;
        }
    }

    return clusterScore;
}

/**
 * Detect terms split across sentence boundaries to evade detection
 */
function detectCrossSentence(text: string): string[] {
    const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
    const hits: string[] = [];

    if (sentences.length < 2) {
        return hits;
    }

    // Check adjacent sentence pairs
    for (let i = 0; i < sentences.length - 1; i++) {
        const combined = sentences[i] + ' ' + sentences[i + 1];
        const combinedNormalized = normalizeText(combined);

        // Check for hard terms in the combined text
        const crossHits = hasTerms(combinedNormalized, HARD_TERMS);
        hits.push(...crossHits);
    }

    return [...new Set(hits)]; // Deduplicate
}

/**
 * Calculate overall context risk score
 */
function calculateContextScore(signals: Partial<Signals>): number {
    let score = 0;

    // Hard terms are highest priority
    score += (signals.hardTerms?.length || 0) * 10;

    // Ambiguous youth terms
    score += (signals.ambiguousYouth?.length || 0) * 4;

    // School context
    score += (signals.schoolContext?.length || 0) * 3;

    // Injections
    score += (signals.injections?.length || 0) * 8;

    // Age under 18
    if (signals.ages?.some(age => age < 18)) {
        score += 15;
    }

    // Cluster score
    score += signals.clusterScore || 0;

    // Cross-sentence detection
    score += (signals.crossSentence?.length || 0) * 6;

    // Fuzzy matches (weighted by confidence)
    if (signals.fuzzyMatches) {
        for (const match of signals.fuzzyMatches) {
            score += Math.ceil(match.confidence * 5);
        }
    }

    // Adult assertions reduce score slightly
    score -= (signals.adultAssertions?.length || 0) * 2;

    return Math.max(0, score);
}

// ============================================================================
// Main Assessment Function
// ============================================================================

/**
 * Assess a prompt for content safety
 * 
 * @param prompt - The text prompt to assess
 * @returns Decision object with allow/block action and detailed signals
 */
export function assess(prompt: string): Decision {
    const raw = prompt;
    let normalized = normalizeText(prompt);
    normalized = normalizeAdultTypos(normalized);

    // Collect basic signals
    const hardTerms = hasTerms(normalized, HARD_TERMS);
    const ambiguousYouth = hasTerms(normalized, AMBIGUOUS_YOUTH);
    const adultAssertions = hasTerms(normalized, ADULT_ASSERTIONS);
    const ages = findAges(normalized);
    const schoolContext = findSchoolContext(normalized);

    // NEW: Collect advanced signals
    const injectionTerms = hasTerms(normalized, INJECTION_TERMS);
    const injectionPatternMatches: string[] = [];
    for (const pattern of INJECTION_PATTERNS) {
        const matches = normalized.matchAll(pattern);
        for (const match of matches) {
            injectionPatternMatches.push(match[0]);
        }
    }
    const injections = [...injectionTerms, ...injectionPatternMatches];

    const crossSentence = detectCrossSentence(normalized);
    const clusterScore = detectClusters(normalized);
    const fuzzyMatches = fuzzyMatchTerms(normalized);

    // Initialize signals object
    const signals: Signals = {
        hardTerms,
        ambiguousYouth,
        adultAssertions,
        ages,
        schoolContext,
        injections,
        crossSentence,
        clusterScore,
        severity: 'UNKNOWN',
        contextScore: 0,
        fuzzyMatches,
        normalized,
    };
    fuzzyMatches: [],  // Will be populated in Phase 2
        normalized,
    };

// Calculate severity and context score
signals.severity = determineSeverity(hardTerms, ambiguousYouth);
signals.contextScore = calculateContextScore(signals);

// Decision logic (priority order)

// 1) Injection attempts → BLOCK (highest priority to prevent jailbreaking)
if (injections.length > 0) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `Injection attempt detected: ${injections.join(', ')}`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 2) Any explicit age < 18 → BLOCK
if (ages.some(age => age < 18)) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `Explicit age under 18 detected (severity: ${signals.severity})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 3) Any hard term → BLOCK
if (hardTerms.length > 0) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `Minor-implying term(s): ${hardTerms.join(', ')} (severity: ${signals.severity})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 4) Cross-sentence detection → BLOCK
if (crossSentence.length > 0) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `Cross-sentence evasion detected: ${crossSentence.join(', ')} (severity: ${signals.severity})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 5) Fuzzy matches for obfuscated content → BLOCK
if (fuzzyMatches.length > 0) {
    const topMatch = fuzzyMatches[0];
    return {
        allow: false,
        action: 'BLOCK',
        reason: `Obfuscated content detected: "${topMatch.window}" matches "${topMatch.term}" (${topMatch.matchType}, confidence: ${topMatch.confidence.toFixed(2)})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 6) K-12 contexts → BLOCK
if (schoolContext.length > 0) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `K-12 school context implies minor (severity: ${signals.severity})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 7) Ambiguous youth descriptors: BLOCK regardless (strict policy)
if (ambiguousYouth.length > 0) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `Ambiguous youth descriptor present (severity: ${signals.severity})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 8) Context score threshold check
if (signals.contextScore >= CONTEXT_SCORE_THRESHOLD) {
    return {
        allow: false,
        action: 'BLOCK',
        reason: `High-risk context score: ${signals.contextScore} (threshold: ${CONTEXT_SCORE_THRESHOLD})`,
        normalizedPrompt: normalized,
        rewrittenPrompt: null,
        signals,
    };
}

// 9) If we get here, allow. Optionally mark as rewritten if normalized.
const rewritten = normalized !== raw ? normalized : null;

return {
    allow: true,
    action: 'ALLOW',
    reason: 'No minor indicators detected',
    normalizedPrompt: normalized,
    rewrittenPrompt: rewritten,
    signals,
};
}

/**
 * Assess a prompt and return JSON string (for CLI/API compatibility)
 */
export function assessJSON(prompt: string): string {
    const decision = assess(prompt);
    return JSON.stringify(decision, null, 0);
}
